<html>
<head>
<link rel=stylesheet href="../howto.css" type="text/css"/>
<title>Advanced Normaliser</title>
</head>
<body>


<h2 style="text-align: center;">WRITING A SIMPLE NORMALISER PLUGIN</h2>
<h4>THE ADVANCED NORMALISER</h4>

<div id="content">
So we have a basic normaliser. It takes a Foo file, and outputs a single XML version of it. But management of organisation X have a surprise in store! Check it out, here is the specification for the next version of the Foo file format....

<ul>
<li>The foo file format is ASCII text, and and contain one or more 'Foo' records.</li>
<li>A foo record begins with the string, 'beginfoo~'.</li>
<li>A foo record will consist of one or more parts, each part being delineated by the '~' character.</li>
<li>The '/' character will escape either the '/' or the '~' character.</li>
<li>Each foo record will end with the string '~endfoo'.</li>
<li>A Foo file, when normalised, should split each foo part into a seperate Archival Information package (xena file).</li>
<li>A Foo file may contain a reference to an external file. In this case, the '/' character will be followed by the 'f' character, followed by a filename enclosed in '"' characters.</li>



<div id="code"><pre>
	public void parse(InputSource input) {	
		ContentHandler contentHandler = getContentHandler();
		AttributesImpl openingAttribute = new AttributesImpl();		
		contentHandler.startElement(FOO_URI, FOO_OPENING_ELEMENT_LOCAL_NAME, 
							FOO_OPENING_ELEMENT_QUALIFIED_NAME, 
							openingAttribute);
<b>		BufferedReader reader = new BufferedReader(source.getCharacterStream());
		char nextChar;
		while ((nextChar = (char)reader.read()) != -1) {
			char[] newCharArray =  {nextChar};
			contentHandler.characters(newCharArray, 0, 1);
		}
</b>		contentHandler.endElement(FOO_URI, FOO_OPENING_ELEMENT_LOCAL_NAME, 
							FOO_OPENING_ELEMENT_QUALIFIED_NAME);
	}
</pre></div>

So far so good, but it doesnt do a great deal further toward getting our Foo contents into the desired schema. So, what is next? well the first thing to do will be to remove the opening "~beginFoo~". Now since the magic number is already defined as a static final string in the FooGuesser, lets make that visible to all and sundry, and then we can access it here. So, based on this, we can update our parse method:

<div id="code"><pre>
	public void parse(InputSource input) {
		ContentHandler contentHandler = getContentHandler();
		AttributesImpl openingAttribute = new AttributesImpl();		
		contentHandler.startElement(FOO_URI, FOO_OPENING_ELEMENT_LOCAL_NAME, 
							FOO_OPENING_ELEMENT_QUALIFIED_NAME, 
							openingAttribute);
		BufferedReader reader = new BufferedReader(source.getCharacterStream());
<b>		long magicNumberLength = (new Integer(FooGuesser.FOO_MAGIC.length)).longValue();
        	reader.skip(magicNumberLength);
</b>		char nextChar;
		while ((nextChar = (char)reader.read()) != -1) {
			char[] newCharArray =  {nextChar};
			contentHandler.characters(newCharArray, 0, 1);
		}
		contentHandler.endElement(FOO_URI, FOO_OPENING_ELEMENT_LOCAL_NAME, 
							FOO_OPENING_ELEMENT_QUALIFIED_NAME);
	}
</pre></div>

Okay, that was easy, so now lets process it a bit further... Now we will add support for checking the character, and if it is a '~', we will close the part tag, and open a new one. But, so as to make sure it is valid XML, we will open a part tag at the beginning, and then close it at the end of processing. So...

<div id="code"><pre><b>	public static final String FOO_PART_ELEMENT_LOCAL_NAME = "part";
	public static final String FOO_PART_ELEMENT_QUALIFIED_NAME = "foo:part";
</b>	public void parse(InputSource input) throws SAXException {
		ContentHandler contentHandler = getContentHandler();
		AttributesImpl openingAttribute = new AttributesImpl();		
		contentHandler.startElement(FOO_URI, FOO_OPENING_ELEMENT_LOCAL_NAME, 
							FOO_OPENING_ELEMENT_QUALIFIED_NAME, 
							openingAttribute);
<b>		AttributesImpl partAttribute = new AttributesImpl();		
		contentHandler.startElement(FOO_URI, FOO_PART_ELEMENT_LOCAL_NAME, 
							FOO_PART_ELEMENT_QUALIFIED_NAME, 
							partAttribute);
</b>		BufferedReader reader = new BufferedReader(source.getCharacterStream());
		int nextCharVal;
		while ( (nextCharVal = reader.read() ) != -1) {
<b>			char currentChar = (char)nextCharVal;
			if (currentChar == '~') {
				contentHandler.startElement(FOO_URI, 
									FOO_PART_ELEMENT_LOCAL_NAME, 
									FOO_PART_ELEMENT_QUALIFIED_NAME, 
									partAttribute);
				contentHandler.endElement(FOO_URI, 
									FOO_PART_ELEMENT_LOCAL_NAME, 
									FOO_PART_ELEMENT_QUALIFIED_NAME);
			} else {
				char[] newCharArray =  {nextChar};
				contentHandler.characters(newCharArray, 0, 1);
			}
</b>        	}
<b>		contentHandler.endElement(FOO_URI, FOO_PART_ELEMENT_LOCAL_NAME, 
							FOO_PART_ELEMENT_QUALIFIED_NAME);
</b>		contentHandler.endElement(FOO_URI, FOO_OPENING_ELEMENT_LOCAL_NAME, 
							FOO_OPENING_ELEMENT_QUALIFIED_NAME);
	}</pre>
</div>

Now that we have this, will it work, and what is our output? After running normaliser tester, the output now looks like this:
<div id="output"><pre>
#java -cp ../../xena/xena.jar;foo.jar au.gov.naa.digipres.xena.demo.foo.test.NormaliseTester
Here is the best guess returned by Xena:
Guess... type: Foo
 possible: Unknown
 dataMatch:True
 magicNumber: True
 extensionMatch: True
 mimeMatch: Unknown
 certain: Unknown
 priority: Default
-----------------------------------------
Here are the results of the normalisation:
Normalisation successful.
The input source name file:/plugin_howto/3_basic_normaliser/source_2/foo_plugin/dist/example_file.foo
normalised to: example_file.foo_Foo.xena
with normaliser: "Foo"
to the folder: /plugin_howto/3_basic_normaliser/source_2/foo_plugin/dist
and the Xena id is: file:/example_file.foo
-----------------------------------------
</pre></div>

And, here is our output. The astute reader will quickly see that there is a problem - we are not taking into account the escape character. This is a fairly simple modification - the only catch is to check for end of stream when we get the character folowing the escape. The only code that will change will be in the while loop within the parse method. For brevity, all else will be excluded. The code is written to maximise clarity rather than efficiency, and since we are going to simply print the character following the escape if it is a '~' or a '\', and ignore the escape otherwise, we can assume that following the escape we will always just write out the character if there is one.

<div id="code"><pre>
		while ( (nextCharVal = reader.read() ) != -1) {
			char currentChar = (char)nextCharVal;
			if (currentChar == '~') {
				contentHandler.startElement(FOO_URI, FOO_PART_ELEMENT_LOCAL_NAME, 
					FOO_PART_ELEMENT_QUALIFIED_NAME, 
					partAttribute);
				contentHandler.endElement(FOO_URI, 
					FOO_PART_ELEMENT_LOCAL_NAME, 
					FOO_PART_ELEMENT_QUALIFIED_NAME);
<b>			} else if (currentChar == '\\') {
				int escapedCharVal = reader.read();
				if (escapedCharVal == -1) {
					break;
				}
				char escapedChar = (char)escapedCharVal;
				char[] escapedCharArray = {escapedChar};
				contentHandler.characters(escapedCharArray, 0, 1);
</b>			} else {
				char[] newCharArray =  {nextChar};
				contentHandler.characters(newCharArray, 0, 1);
			}
</pre></div>

</div>
</body>
</head>









